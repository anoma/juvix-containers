module Test.Queue;

import Stdlib.Prelude open hiding {head; tail};
import Stdlib.Data.Nat open;
import Stdlib.Data.Maybe open;
import Test.JuvixUnit open;
import Data.Queue open;

q : Queue Nat := empty;

q1 : Queue Nat := push 1 q;

q2 : Queue Nat := push 2 q1;

q3 : Queue Nat := push 3 q2;

q4 : Queue Nat := push 4 q3;

tests : List Test :=
  let
    checkWithList : Queue Nat -> List Nat -> Assertion
      | q q' :=
        assertEqual
          eqQueueI
          "Queue should be equal"
          q
          (fromList q');
  in [testCase
    "Queue.empty should be empty"
    (checkWithList q []); testCase
    "Queue.push should add an element"
    (checkWithList q1 [1]); testCase
    "Queue.push first element should be first pushed"
    (checkWithList q2 [2; 1]); testCase
    "Queue.head should return first element"
    (assertEqual
      eqMaybeI
      "head of queue q3"
      (head q3)
      (just 1)); testCase
    "Queue.fromList composes with toList should be the identity"
    (assertEqual
      eqQueueI
      "fromList . toList should be the identity"
      (fromList ∘ toList $ q3)
      q3); testCase
    "Queue.pop should remove first element"
    (assertEqual
      eqMaybeI
      "pop of queue q3"
      (pop q3)
      (just (1, fromList [3; 2]))); testCase
    "Queue.tail should return queue without first element"
    (assertEqual
      eqMaybeI
      "tail of queue q3"
      (tail q3)
      ((just ∘ fromList) [3; 2]))];

main : IO := runTestSuite $ testSuite "Queue" tests;
