module Data.Eq;

open import Stdlib.Prelude;
open import Data.Ordering;

import Stdlib.Data.Nat.Ord;
import Stdlib.Data.String.Ord;

type Eq (A : Type) :=
  | eq : (A -> A -> Bool) -> Eq A;

zipWith :
  {A : Type}
    → {B : Type}
    → {C : Type}
    → (A → B → C)
    → List A
    → List B
    → List C;
zipWith f nil _ := nil;
zipWith f _ nil := nil;
zipWith f (x :: xs) (y :: ys) := f x y :: zipWith f xs ys;

all : List Bool -> Bool;
all := foldl and true;

eq-== : {A : Type} -> Eq A -> A -> A -> Bool;
eq-== (eq op) := op;

eq-ordering : {A : Type} -> Ordering A -> Eq A;
eq-ordering ord := eq (ordering-eq ord);

nat-eq : Eq Nat;
nat-eq := eq-ordering nat-ordering;

string-eq : Eq String;
string-eq := eq (Stdlib.Data.String.Ord.==);

list-eq : {A : Type} -> Eq A -> Eq (List A);
list-eq {A} (eq a-eq) :=
  let
    op : List A -> List A -> Bool;
    op l1 l2 :=
      let
        test-elems : Bool := all (zipWith a-eq l1 l2);
        test-length :
            Bool := length l1 Stdlib.Data.Nat.Ord.== length l2;
      in test-elems && test-length;
  in eq op;
