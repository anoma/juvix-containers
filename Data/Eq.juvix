module Data.Eq;

open import Stdlib.Prelude;
open import Data.Ord;

import Stdlib.Data.Nat.Ord;
import Stdlib.Data.String.Ord;

type Eq (A : Type) :=
  | eq : (A -> A -> Bool) -> Eq A;

zipWith :
  {A : Type}
    → {B : Type}
    → {C : Type}
    → (A → B → C)
    → List A
    → List B
    → List C;
zipWith f nil _ := nil;
zipWith f _ nil := nil;
zipWith f (x :: xs) (y :: ys) := f x y :: zipWith f xs ys;

all : List Bool -> Bool;
all := foldl and true;

eq-== : {A : Type} -> Eq A -> A -> A -> Bool;
eq-== (eq op) := op;

eq-ordering : {A : Type} -> Ord A -> Eq A;
eq-ordering o := eq (ordering-eq o);

nat-eq : Eq Nat;
nat-eq := eq-ordering nat-ordering;

string-eq : Eq String;
string-eq := eq (Stdlib.Data.String.Ord.==);

pair-eq : {A B : Type} -> Eq A -> Eq B -> Eq (A × B);
pair-eq (eq eq-a) (eq eq-b) :=
  eq
    λ {
      | (a1, b1) (a2, b2) := eq-a a1 a2 && eq-b b1 b2
    };

list-eq : {A : Type} -> Eq A -> Eq (List A);
list-eq {A} (eq a-eq) :=
  let
    op : List A -> List A -> Bool;
    op l1 l2 :=
      let
        test-elems : Bool := all (zipWith a-eq l1 l2);
        test-length :
            Bool := length l1 Stdlib.Data.Nat.Ord.== length l2;
      in test-elems && test-length;
  in eq op;
