module Data.UnbalancedSet;

import Stdlib.Prelude open hiding {length};

import Test.JuvixUnit open;

import Stdlib.Trait.Ord as Ord;

import Data.BinaryTree as Tree;
open Tree using {BinaryTree; leaf; node};

type UnbalancedSet (A : Type) :=
  unbalancedSet : Ord A -> BinaryTree A -> UnbalancedSet A;

empty : {A : Type} -> Ord A -> UnbalancedSet A
  | o := unbalancedSet o leaf;

member? : {A : Type} -> A -> UnbalancedSet A -> Bool
  | {A} x (unbalancedSet o@(mkOrd cmp) t) :=
    let
      go : BinaryTree A -> Bool
        | leaf := false
        | (node l y r) :=
          case cmp x y of {
            | Ord.LT := go l
            | Ord.GT := go r
            | Ord.EQ := true
          };
    in go t;

insert
  : {A : Type} -> A -> UnbalancedSet A -> UnbalancedSet A
  | {A} x (unbalancedSet o@(mkOrd cmp) t) :=
    let
      go : BinaryTree A -> BinaryTree A
        | leaf := node leaf x leaf
        | n@(node l y r) :=
          case cmp x y of {
            | Ord.LT := node (go l) y r
            | Ord.EQ := n
            | Ord.GT := node l y (go r)
          };
    in unbalancedSet o (go t);

length : {A : Type} -> UnbalancedSet A -> Nat
  | (unbalancedSet _ t) := Tree.length t;

to-list : {A : Type} -> UnbalancedSet A -> List A
  | (unbalancedSet _ t) := Tree.to-list t;

set-ordering : {A : Type} -> Ord A -> Ord (UnbalancedSet A)
  | {A} o :=
    let
      from-ord-list : Ord (List A) -> Ord (UnbalancedSet A)
        | (mkOrd cmp) :=
          mkOrd Î» {s1 s2 := cmp (to-list s1) (to-list s2)};
    in from-ord-list (ordListI {{o}});
