module Data.Ord;

open import Stdlib.Prelude;
open import Stdlib.Data.Ord;

import Stdlib.Data.Nat.Ord as Nat;

--- A class for totally ordered types
type Ord (A : Type) :=
  | ord : (A -> A -> Ordering) -> Ord A;

ordering-eq : {A : Type} -> Ord A -> A -> A -> Bool;
ordering-eq (ord f) a1 a2 := isEQ (f a1 a2);

ordering-lt : {A : Type} -> Ord A -> A -> A -> Bool;
ordering-lt (ord f) a1 a2 := isLT (f a1 a2);

ordering-leq : {A : Type} -> Ord A -> A -> A -> Bool;
ordering-leq (ord f) a1 a2 :=
  let
    cmp : Ordering;
    cmp := f a1 a2;
  in isLT cmp || isEQ cmp;

ordering-gt : {A : Type} -> Ord A -> A -> A -> Bool;
ordering-gt (ord f) a1 a2 := isGT (f a1 a2);

nat-ordering : Ord Nat;
nat-ordering := ord Nat.compare;

pair-ordering :
  {A B : Type} -> Ord A -> Ord B -> Ord (A × B);
pair-ordering (ord cmp-a) (ord cmp-b) :=
  ord
    λ {
      | (a1, b1) (a2, b2) :=
        case cmp-a a1 a2
          | LT := LT
          | GT := GT
          | EQ := cmp-b b1 b2
    };

list-ordering : {A : Type} -> Ord A -> Ord (List A);
list-ordering {A} (ord cmp-a) :=
  let
    go : List A -> List A -> Ordering;
    go nil nil := EQ;
    go nil _ := LT;
    go _ nil := GT;
    go (x :: xs) (y :: ys) :=
      case cmp-a x y
        | LT := LT
        | GT := GT
        | EQ := go xs ys;
  in ord go;

terminating
quickSort : {A : Type} → Ord A → List A → List A;
quickSort _ nil := nil;
quickSort _ (x :: nil) := x :: nil;
quickSort {A} o (x :: xs) :=
  let
    qsHelper : A → List A × List A → List A;
    qsHelper a (l, r) := l ++ (a :: nil) ++ r;
    isGT : A -> Bool;
    isGT := ordering-gt o x;
  in qsHelper x (both (quickSort o) (partition isGT xs));
