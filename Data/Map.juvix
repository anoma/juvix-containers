module Data.Map;

open import Stdlib.Prelude hiding {length};

import Stdlib.Data.Nat.Ord as Nat;
import Data.Set as Set;
import Data.BinaryTree as Tree;

open import Test.JuvixUnit;

type Binding (A B : Type) :=
  | binding : A -> B -> Binding A B;

key : {A B : Type} -> Binding A B -> A;
key (binding a _) := a;

value : {A B : Type} -> Binding A B -> B;
value (binding _ b) := b;

to-pair : {A B : Type} -> Binding A B -> A × B;
to-pair (binding a b) := a, b;

binding-key-ordering :
  {A B : Type} -> Ord A -> Ord (Binding A B);
binding-key-ordering (mkOrd cmp) :=
  mkOrd
    λ {
      | b1 b2 := cmp (key b1) (key b2)
    };

type FiniteMap (A B : Type) :=
  | finiteMap : Ord A
      -> Set.UnbalancedSet (Binding A B)
      -> FiniteMap A B;

Map : Type -> Type -> Type;
Map A B := FiniteMap A B;

empty : {A B : Type} -> Ord A -> FiniteMap A B;
empty o := finiteMap o (Set.empty (binding-key-ordering o));

bind-with :
  {A B : Type}
    -> (B -> B -> B)
    -> A
    -> B
    -> FiniteMap A B
    -> FiniteMap A B;
bind-with {A} {B} f k v (finiteMap o@(mkOrd cmp) (Set.unbalancedSet _ t)) :=
  let
    go :
        Tree.BinaryTree (Binding A B)
          -> Tree.BinaryTree (Binding A B);
    go Tree.leaf := Tree.node Tree.leaf (binding k v) Tree.leaf;
    go n@(Tree.node l b r) :=
      let
        mergeBinding : Binding A B;
        mergeBinding := binding (key b) (f (value b) v);
      in case cmp k (key b)
        | EQ := Tree.node l mergeBinding r
        | LT := Tree.node (go l) b r
        | GT := Tree.node l b (go r);
  in finiteMap
    o
    (Set.unbalancedSet (binding-key-ordering o) (go t));

bind :
  {A B : Type} -> A -> B -> FiniteMap A B -> FiniteMap A B;
bind :=
  bind-with
    λ {
      | old new := new
    };

lookup : {A B : Type} -> A -> FiniteMap A B -> Maybe B;
lookup {A} {B} k (finiteMap (mkOrd cmp) (Set.unbalancedSet _ t)) :=
  let
    go : Tree.BinaryTree (Binding A B) -> Maybe B;
    go Tree.leaf := nothing;
    go (Tree.node l b r) :=
      case cmp k (key b)
        | EQ := just (value b)
        | LT := go l
        | GT := go r;
  in go t;

from-list-with :
  {A B : Type}
    -> Ord A
    -> (B -> B -> B)
    -> List (A × B)
    -> FiniteMap A B;
from-list-with o f :=
  foldl
    λ {
      | m (k, v) := bind-with f k v m
    }
    (empty o);

to-list : {A B : Type} -> FiniteMap A B -> List (A × B);
to-list (finiteMap _ s) := map to-pair (Set.to-list s);

length : {A B : Type} -> FiniteMap A B -> Nat;
length (finiteMap _ uset) := Set.length uset;
