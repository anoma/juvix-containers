module Data.Map;

open import Stdlib.Prelude hiding {length};

import Stdlib.Data.Nat.Ord as Nat;
import Data.Set as Set;
open Set using {Set};
import Data.BinaryTree as Tree;
open import Data.Tmp;

open import Test.JuvixUnit;

type Binding (A B : Type) :=
  | binding : A -> B -> Binding A B;

key : {A B : Type} -> Binding A B -> A;
key (binding a _) := a;

value : {A B : Type} -> Binding A B -> B;
value (binding _ b) := b;

toPair : {A B : Type} -> Binding A B -> A × B;
toPair (binding a b) := a, b;

bindingKeyOrdering :
  {A B : Type} -> Ord A -> Ord (Binding A B);
bindingKeyOrdering (mkOrd cmp) :=
  mkOrd
    λ {
      | b1 b2 := cmp (key b1) (key b2)
    };
type Map (A B : Type) :=
  mkMap : Set (Binding A B) -> Map A B;

empty : {A B : Type} -> Map A B;
empty := mkMap Set.empty;

insertWith :
  {A B : Type}
    -> Ord A
    -> (B -> B -> B)
    -> A
    -> B
    -> Map A B
    -> Map A B;
insertWith {A} {B} o f k v (mkMap s) :=
  let
    f' : Binding A B -> Binding A B -> Binding A B;
    f' (binding a b1) (binding _ b2) := binding a (f b1 b2);
  in
    mkMap (Set.insertWith (bindingKeyOrdering o) f' (binding k v) s);

insert :
  {A B : Type} -> Ord A -> A -> B -> Map A B -> Map A B;
insert o :=
  insertWith o
    λ {
      | old new := new
    };

lookup : {A B : Type} -> Ord A -> A -> Map A B -> Maybe B;
lookup {A} {B} o k (mkMap s) := mapMaybe value (Set.lookupWith o key k s);

from-list-with :
  {A B : Type}
    -> Ord A
    -> (B -> B -> B)
    -> List (A × B)
    -> Map A B;
from-list-with o f :=
  foldl
    λ {
      | m (k, v) := insertWith o f k v m
    }
    empty;

toList : {A B : Type} -> Map A B -> List (A × B);
toList (mkMap s) := map toPair (Set.toList s);

size : {A B : Type} -> Map A B -> Nat;
size (mkMap s) := Set.size s;
